<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sopas de Letras</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --bg-color: #0f172a;
            --accent: #f43f5e;
            --grid-bg: #1e293b;
            --text: #f8fafc;
            --found: #10b981;
            --secret: #8b5cf6;
        }
        body { background: var(--bg-color); color: var(--text); font-family: 'Roboto', sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; min-height: 100vh; touch-action: none; }
        
        .header-bar { width: 100%; padding: 15px; display: flex; justify-content: space-between; align-items: center; background: rgba(0,0,0,0.3); }
        .back-btn { color: white; text-decoration: none; display: flex; gap: 5px; align-items: center; background: rgba(255,255,255,0.1); padding: 5px 12px; border-radius: 20px; }
        
        /* Layout */
        .game-layout { display: flex; flex-direction: column; gap: 20px; padding: 10px; width: 100%; max-width: 500px; align-items: center; }
        
        /* Grid */
        .grid { display: grid; gap: 2px; padding: 5px; background: var(--grid-bg); border-radius: 8px; user-select: none; }
        .cell { 
            width: 35px; height: 35px; display: flex; justify-content: center; align-items: center; 
            font-weight: bold; text-transform: uppercase; border-radius: 4px; cursor: pointer; color: #94a3b8;
            transition: 0.2s;
        }
        .cell.selected { background: var(--accent); color: white; transform: scale(1.1); }
        .cell.found { background: var(--found); color: white; animation: pop 0.3s; }
        .cell.secret { background: var(--secret); color: white; animation: pulse 1s infinite; }
        .cell.hint-highlight { border: 2px solid #fbbf24; background: rgba(251, 191, 36, 0.2); }

        /* Words List */
        .word-list { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; padding: 0; list-style: none; }
        .word-tag { background: rgba(255,255,255,0.05); padding: 5px 10px; border-radius: 4px; font-size: 0.9rem; }
        .word-tag.done { text-decoration: line-through; opacity: 0.5; color: var(--found); }

        /* Controls */
        .controls { display: flex; gap: 15px; margin-top: 10px; }
        .action-btn { background: #334155; border: none; color: white; padding: 10px 20px; border-radius: 50px; cursor: pointer; display: flex; align-items: center; gap: 8px; font-weight: bold; }
        .hint-btn { background: #fbbf24; color: #451a03; }

        /* Modals */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 100; padding: 20px; }
        .modal-box { background: var(--grid-bg); padding: 30px; border-radius: 16px; text-align: center; border: 1px solid var(--accent); max-width: 400px; width: 100%; }
        
        @keyframes pop { 50% { transform: scale(1.2); } }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(139, 92, 246, 0); } 100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0); } }
    </style>
</head>
<body>
    <div class="header-bar">
        <a href="../index.html" class="back-btn"><i data-lucide="arrow-left" size="16"></i> Salir</a>
        <div id="level-title">Nivel 1</div>
    </div>

    <div class="game-layout">
        <div id="grid-container" class="grid"></div>

        <ul id="word-list" class="word-list"></ul>

        <div class="controls">
            <button class="action-btn hint-btn" onclick="game.useHint()">
                <i data-lucide="lightbulb" size="18"></i> Pista (5)
            </button>
            <button class="action-btn" onclick="game.resetLevel()">
                <i data-lucide="rotate-ccw" size="18"></i> Reiniciar
            </button>
        </div>
    </div>

    <div id="win-modal" class="modal-overlay">
        <div class="modal-box">
            <i data-lucide="trophy" size="48" color="#fbbf24" style="margin-bottom:15px"></i>
            <h2>¡Nivel Completado!</h2>
            <p id="win-msg">Mensaje romántico aquí...</p>
            <button class="action-btn" style="width:100%; justify-content:center; background: var(--accent); margin-top:20px;" onclick="game.nextLevel()">
                Siguiente Nivel
            </button>
        </div>
    </div>

    <div id="end-modal" class="modal-overlay">
        <div class="modal-box">
            <i data-lucide="heart-handshake" size="48" color="#f43f5e" style="margin-bottom:15px"></i>
            <h2>¡Todo Completado!</h2>
            <p>Has terminado todos los niveles disponibles por ahora. ¡Vuelve pronto para más sorpresas!</p>
            <a href="../index.html" class="action-btn" style="width:100%; justify-content:center; margin-top:20px;">
                Volver al Menú
            </a>
        </div>
    </div>

    <script src="../js/app.js"></script>
    <script>
        // --- NIVELES (Palabras secretas añadidas) ---
        const levels = [
            { 
                id: 1, 
                words: ["AMOR", "VIDA", "SOL", "LUNA"], 
                secret: ["BESO"], // Secreto
                msg: "Eres mi sol y mi luna." 
            },
            { 
                id: 2, 
                words: ["CIELO", "MAR", "LUZ", "PAZ"], 
                secret: ["PASION"], // Secreto
                msg: "Contigo encuentro paz." 
            },
             { 
                id: 3, 
                words: ["DULCE", "SUEÑO", "RISA", "MAGIA"], 
                secret: ["ETERNIDAD"], 
                msg: "Tu risa es mi magia favorita." 
            }
        ];

        class WordSearch {
            constructor() {
                this.gridSize = 10;
                this.state = { levelIdx: 0, found: [], grid: [], selection: [] };
                this.dom = {
                    grid: document.getElementById('grid-container'),
                    list: document.getElementById('word-list'),
                    title: document.getElementById('level-title')
                };
                
                this.loadProgress();
            }

            loadProgress() {
                // Recuperar último nivel jugado
                const saved = localStorage.getItem('ws_level_idx');
                if (saved) this.state.levelIdx = parseInt(saved);
                this.initLevel();
            }

            initLevel() {
                // CORRECCIÓN: Evitar reinicio. Si acabaste, muestra fin.
                if (this.state.levelIdx >= levels.length) {
                    document.getElementById('end-modal').style.display = 'flex';
                    return;
                }

                this.level = levels[this.state.levelIdx];
                this.state.found = [];
                this.state.selection = [];
                this.dom.title.textContent = `Nivel ${this.state.levelIdx + 1}`;
                
                this.renderUI();
                this.generateGrid();
            }

            generateGrid() {
                // Crear grid vacía
                const grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(''));
                const allWords = [...this.level.words, ...this.level.secret];

                // Colocar palabras (Algoritmo simple)
                allWords.forEach(word => {
                    let placed = false;
                    let attempts = 0;
                    while(!placed && attempts < 100) {
                        const dir = Math.random() > 0.5 ? [0,1] : [1,0]; // Horiz o Vert
                        const r = Math.floor(Math.random() * this.gridSize);
                        const c = Math.floor(Math.random() * this.gridSize);
                        if(this.canPlace(grid, word, r, c, dir)) {
                            this.place(grid, word, r, c, dir);
                            placed = true;
                        }
                        attempts++;
                    }
                });

                // Rellenar vacíos
                const letters = "ABCDEFGHIJKLMNÑOPQRSTUVWXYZ";
                for(let r=0; r<this.gridSize; r++) {
                    for(let c=0; c<this.gridSize; c++) {
                        if(grid[r][c] === '') grid[r][c] = letters.charAt(Math.floor(Math.random() * letters.length));
                    }
                }
                this.state.grid = grid;
                this.drawGrid();
            }

            canPlace(grid, word, r, c, dir) {
                if (r + dir[0] * word.length > this.gridSize || c + dir[1] * word.length > this.gridSize) return false;
                for(let i=0; i<word.length; i++) {
                    const char = grid[r + dir[0]*i][c + dir[1]*i];
                    if(char !== '' && char !== word[i]) return false;
                }
                return true;
            }

            place(grid, word, r, c, dir) {
                for(let i=0; i<word.length; i++) {
                    grid[r + dir[0]*i][c + dir[1]*i] = word[i];
                }
            }

            drawGrid() {
                this.dom.grid.innerHTML = '';
                this.dom.grid.style.gridTemplateColumns = `repeat(${this.gridSize}, 1fr)`;
                
                this.state.grid.forEach((row, r) => {
                    row.forEach((char, c) => {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.textContent = char;
                        cell.dataset.r = r; cell.dataset.c = c;
                        
                        // Eventos Touch/Mouse
                        const start = (e) => { e.preventDefault(); this.selectStart(r, c); };
                        const move = (e) => { 
                            e.preventDefault(); 
                            // Soporte touch move
                            const touch = e.touches ? e.touches[0] : null;
                            if(touch) {
                                const el = document.elementFromPoint(touch.clientX, touch.clientY);
                                if(el && el.dataset.r) this.selectMove(parseInt(el.dataset.r), parseInt(el.dataset.c));
                            } else {
                                this.selectMove(r, c); 
                            }
                        };
                        
                        cell.addEventListener('mousedown', start);
                        cell.addEventListener('mouseenter', move);
                        cell.addEventListener('touchstart', start, {passive: false});
                        cell.addEventListener('touchmove', move, {passive: false});

                        this.dom.grid.appendChild(cell);
                    });
                });

                document.addEventListener('mouseup', () => this.selectEnd());
                document.addEventListener('touchend', () => this.selectEnd());
            }

            renderUI() {
                this.dom.list.innerHTML = this.level.words.map(w => `<li class="word-tag" id="w-${w}">${w}</li>`).join('');
            }

            // --- Lógica de Selección ---
            selectStart(r, c) {
                this.selecting = true;
                this.startPos = {r, c};
                this.updateSelection(r, c);
            }

            selectMove(r, c) {
                if(!this.selecting) return;
                this.updateSelection(r, c);
            }

            updateSelection(endR, endC) {
                // Limpiar visual
                document.querySelectorAll('.cell.selected').forEach(el => el.classList.remove('selected'));
                this.state.selection = [];

                // Calcular línea (Bresenham simplificado para ortogonales/diagonales)
                const dr = endR - this.startPos.r;
                const dc = endC - this.startPos.c;
                
                // Forzar 8 direcciones
                if(dr === 0 || dc === 0 || Math.abs(dr) === Math.abs(dc)) {
                    const steps = Math.max(Math.abs(dr), Math.abs(dc));
                    const stepR = dr === 0 ? 0 : dr/steps;
                    const stepC = dc === 0 ? 0 : dc/steps;
                    
                    for(let i=0; i<=steps; i++) {
                        const r = this.startPos.r + i*stepR;
                        const c = this.startPos.c + i*stepC;
                        const idx = r * this.gridSize + c;
                        const cell = this.dom.grid.children[idx];
                        if(cell) {
                            cell.classList.add('selected');
                            this.state.selection.push(cell);
                        }
                    }
                }
            }

            selectEnd() {
                if(!this.selecting) return;
                this.selecting = false;
                
                const word = this.state.selection.map(c => c.textContent).join('');
                const revWord = word.split('').reverse().join('');
                
                this.checkWord(word) || this.checkWord(revWord);
                
                // Limpiar
                document.querySelectorAll('.cell.selected').forEach(el => el.classList.remove('selected'));
            }

            checkWord(word) {
                // 1. Palabra Normal
                if(this.level.words.includes(word) && !this.state.found.includes(word)) {
                    this.state.found.push(word);
                    this.markFound(word, 'found');
                    document.getElementById(`w-${word}`).classList.add('done');
                    
                    if(this.state.found.length === this.level.words.length) {
                        setTimeout(() => this.levelComplete(), 500);
                    }
                    return true;
                }
                
                // 2. Palabra Secreta (+50 Monedas)
                if(this.level.secret.includes(word)) {
                    // Generar ID único para no cobrar doble: LevelID + Word
                    const uniqueId = `lvl${this.level.id}_${word}`;
                    const success = GameCenter.claimSecretWord(uniqueId, 50);
                    
                    this.markFound(word, 'secret');
                    alert(`✨ ¡SECRETO ENCONTRADO! ✨\nPalabra: ${word}\nRecompensa: +50 Monedas`);
                    return true;
                }
                return false;
            }

            markFound(word, className) {
                this.state.selection.forEach(cell => {
                    cell.classList.remove('selected');
                    cell.classList.add(className);
                });
            }

            // --- SISTEMA DE PISTAS ---
            useHint() {
                // Buscar palabra pendiente
                const pending = this.level.words.find(w => !this.state.found.includes(w));
                if(!pending) return;

                if(!GameCenter.spendCoins(5)) {
                    alert("No tienes suficientes monedas (Costo: 5)");
                    return;
                }

                // Buscar primera letra de esa palabra en la grid
                // (Nota: Esto es una simplificación, busca cualquier instancia de la primera letra)
                // Para hacerlo perfecto, deberíamos guardar las coordenadas al generar.
                // Método de búsqueda visual:
                for(let r=0; r<this.gridSize; r++) {
                    for(let c=0; c<this.gridSize; c++) {
                        if(this.state.grid[r][c] === pending[0]) {
                            // Verificar si esta letra es el inicio de la palabra correcta
                            // (Simplificado: solo ilumina la letra)
                            const idx = r * this.gridSize + c;
                            const cell = this.dom.grid.children[idx];
                            if(!cell.classList.contains('found')) {
                                cell.classList.add('hint-highlight');
                                setTimeout(() => cell.classList.remove('hint-highlight'), 1000);
                                return; // Solo una pista
                            }
                        }
                    }
                }
            }

            levelComplete() {
                // Pagar Nivel (50 monedas)
                const res = GameCenter.completeLevel('wordsearch', this.state.levelIdx, 50);
                
                document.getElementById('win-msg').innerHTML = 
                    `${this.level.msg}<br><br>` + 
                    (res.paid ? `<span style='color:#10b981'>+50 Monedas ganadas!</span>` : `<span style='color:#94a3b8'>Nivel completado (Replay)</span>`);
                
                document.getElementById('win-modal').style.display = 'flex';
            }

            nextLevel() {
                this.state.levelIdx++;
                localStorage.setItem('ws_level_idx', this.state.levelIdx);
                document.getElementById('win-modal').style.display = 'none';
                this.initLevel();
            }
            
            resetLevel() {
                this.initLevel();
            }
        }

        lucide.createIcons();
        const game = new WordSearch();
    </script>
</body>
</html>
